import cv2
import numpy as np

class SSD_TF:

    # https://jeanvitor.com/tensorflow-object-detection-opencv/
    # graph.pbtxt has to be generated by running opencv dnn scripts
    # python tf_text_graph_ssd.py --input ./3/frozen_inference_graph.pb \
    # --config ./3/pipeline.config --output ./3/graph.pbtxt

    # https://www.pyimagesearch.com/2017/11/06/deep-learning-opencvs-blobfromimage-works/


    def __init__(self,
                 frozen_graph_path='./tf_files/3/frozen_inference_graph.pb',
                 config_pbtxt_path='./tf_files/3/graph.pbtxt',
                 labelmap_path=None):
        """
        Args:
            frozen_graph_path (str): Path to frozen graph file.
            config_pbtxt_path (str): Path to config file generated from frozen graph.
        """
        self.fg = frozen_graph_path
        self.gtxt = config_pbtxt_path
        self.net = cv2.dnn.readNetFromTensorflow(frozen_graph_path,
                                                 config_pbtxt_path)


    def fprop(self, inpt_img):
        self.net.setInput(cv2.dnn.blobFromImage(inpt_img, 
            size=(300, 300), 
            swapRB=True,
            crop=False
        ))  # also converts to the proper tensor
        
        # shape could pertain to (batch size, "channels", n_dtections, features)
        self.output_tensor = self.net.forward() # (1, 1, 100, 7)

        def score_mapper(farray):
            return farray[2]

        def bb_mapper(farray):
            # (xmin, ymin, xmax, ymax)
            return farray[3], farray[4], farray[5], farray[6]

        # TODO: find where predicted class lays in this tensor    
        self.out_scores = np.array(
            list(map(score_mapper, self.output_tensor[0,0]))
        )
        self.bouding_boxes = np.array(
            list(map(bb_mapper, self.output_tensor[0,0]))
        ).reshape((-1, 4))
        return self


    def filter_results(self, min_prob=.8):
        self.idx = np.argwhere(self.out_scores > min_prob)


    def get_bounding_boxes(self):
        return self.bouding_boxes[self.idx]


    def get_scores(self):
        return self.out_scores[self.idx]


if __name__ == '__main__':
    img = cv2.imread(filename='./tf_files/sample_a.jpg')
    height, width = list(img.shape)[:2]

    model = SSD_TF()
    model.fprop(img)
    idx = np.argwhere(model.out_scores > .8)  # min thresh
    bbs = model.bouding_boxes[idx]

    for bb in bbs:
        xmin, ymin, xmax, ymax = bb.reshape(4)

        xmin = int(xmin * width)
        xmax = int(xmax * width)
        
        ymin = int(ymin * height)
        ymax = int(ymax * height)

        cv2.rectangle(
            img,
            (xmin, ymin),
            (xmax, ymax),
            (0, 225, 0),
            thickness=2
        )
            
    cv2.imshow('Image', img)
    cv2.waitKey()
    cv2.destroyAllWindows()


# tensorflowNet.setInput(cv2.dnn.blobFromImage(img, size=(300, 300), swapRB=True, crop=False))

# # Runs a forward pass to compute the net output
# networkOutput = tensorflowNet.forward()

# # Loop on the outputs
# for detection in networkOutput[0,0]:
    
#     score = float(detection[2])
#     if score > 0.2:
    	
#         left = detection[3] * cols
#         top = detection[4] * rows
#         right = detection[5] * cols
#         bottom = detection[6] * rows

#         #draw a red rectangle around detected objects
#         cv2.rectangle(img, (int(left), int(top)), (int(right), int(bottom)), (0, 0, 255), thickness=2)

# # Show the image with a rectagle surrounding the detected objects 

